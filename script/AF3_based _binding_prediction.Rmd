---
title: "AF_based_binding_prediction"
author: "Jerry Li"
date: "2024-07-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load required libraries
library(ggplot2)
library(dplyr)

# Read the data
data <- read.csv("../input/af3/ipTM_ploting.csv")

# Define the range of cutoffs and expand the data
cutoffs <- seq(0.7, 0.9, by = 0.01)
expanded_data <- data %>% 
  crossing(Cutoff = cutoffs) %>% 
  mutate(
    Cutoff = as.numeric(Cutoff),  # Ensure Cutoff is numeric
    Accurate = ifelse(Average_ipTM >= Cutoff & Experimental_Result == "Yes" |
                      Average_ipTM < Cutoff & Experimental_Result == "No", 1, 0),
    Type_1_Error = ifelse(Average_ipTM >= Cutoff & Experimental_Result == "No", 1, 0),
    Type_2_Error = ifelse(Average_ipTM < Cutoff & Experimental_Result == "Yes", 1, 0)
  ) %>% 
  group_by(Cutoff) %>% 
  summarise(
    Accuracy = mean(Accurate),
    Type_1_Error_Rate = mean(Type_1_Error),
    Type_2_Error_Rate = mean(Type_2_Error),
    .groups = 'drop'
  )

# Find the optimal cutoff where accuracy is maximum
optimal_cutoff_index <- which.max(expanded_data$Accuracy)
optimal_cutoff <- expanded_data$Cutoff[optimal_cutoff_index]
max_accuracy <- expanded_data$Accuracy[optimal_cutoff_index]
max_type_1_error_rate <- expanded_data$Type_1_Error_Rate[optimal_cutoff_index]
max_type_2_error_rate <- expanded_data$Type_2_Error_Rate[optimal_cutoff_index]

# Output results
cat("Optimal ipTM Cutoff:", optimal_cutoff, "\n")
cat("Highest Accuracy:", max_accuracy * 100, "%\n")
cat("Type 1 Error Rate at Optimal Cutoff:", max_type_1_error_rate * 100, "%\n")
cat("Type 2 Error Rate at Optimal Cutoff:", max_type_2_error_rate * 100, "%\n")

# Plotting
ggplot(expanded_data, aes(x = Cutoff)) +
  geom_line(aes(y = Accuracy, color = "Accuracy"), size = 1.2) +
  geom_line(aes(y = Type_1_Error_Rate, color = "Type 1 Error Rate"), size = 1) +
  geom_line(aes(y = Type_2_Error_Rate, color = "Type 2 Error Rate"), size = 1) +
  geom_vline(xintercept = 0.83, linetype = "dashed", color = "gray", size = 0.5) +
  geom_hline(yintercept = 0.788, linetype = "dashed", color = "gray", size = 0.5) +
  scale_color_manual(values = c("Accuracy" = "#4477aa", "Type 1 Error Rate" = "#ee6677", "Type 2 Error Rate" = "#ccbb44")) +
  labs(x = "Average ipTM Cutoff", y = "Performance Metrics", title = "AF3 Accuracy") +
  my_ggplot_theme

ggsave("../output/af3/AF3_accuracy.pdf", dpi = 300, width = 8, height = 5)


```


```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(tidyr)

# Load and prepare the data
data <- read.csv("../input/af3/ipTM_ploting.csv")

data_processed <- data %>%
  mutate(
    Accuracy = ifelse((Average_ipTM >= 0.83 & Experimental_Result == "Yes") | 
                      (Average_ipTM < 0.83 & Experimental_Result == "No"), 1, 0),
    Type_1_Error = ifelse(Average_ipTM >= 0.83 & Experimental_Result == "No", 1, 0),
    Type_2_Error = ifelse(Average_ipTM < 0.83 & Experimental_Result == "Yes", 1, 0)
  ) %>%
  group_by(flg22_variants) %>%
  summarise(
    Accuracy_Percentage = mean(Accuracy) * 100,
    Type_1_Error_Percentage = mean(Type_1_Error) * 100,
    Type_2_Error_Percentage = mean(Type_2_Error) * 100,
    .groups = 'drop'
  )

# Correctly pivot the data
data_long <- data_processed %>%
  pivot_longer(
    cols = c("Accuracy_Percentage", "Type_1_Error_Percentage", "Type_2_Error_Percentage"),
    names_to = "Metric",
    values_to = "Percentage"
  ) %>%
  mutate(Metric = gsub("_Percentage$", "", Metric))

# Set the order of flg22 variants as in the similarity matrix
variant_order <- c("csp22", "Paeflg22", "Atuflg22", "Ddaflg22", "Rrhflg22", "Eamflg22", "Pviflg22", "Rso_1flg22", "Rso_2flg22", "Xfrflg22", "Xorflg22")
data_long$flg22_variants <- factor(data_long$flg22_variants, levels = variant_order)
data_long$Metric <- factor(data_long$Metric, levels = c("Type_1_Error", "Type_2_Error", "Accuracy"))
# Prepare similarity data
similarity_data <- data.frame(
  flg22_variants = variant_order,
  sim = c(24.1, 100, 50, 36.4, 59.1, 68.2, 63.6, 63.6, 31.8, 59.1, 59.1)
)
similarity_data$flg22_variants <- factor(similarity_data$flg22_variants, levels = variant_order)

# Plot
stacked_plot <- ggplot(data_long, aes(x = flg22_variants, y = Percentage, fill = Metric)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = c("Accuracy" = "#4477aa", "Type_1_Error" = "#ee6677", "Type_2_Error" = "#ccbb44")) +
  labs(title = "Metrics for Each flg22 Variant at ipTM Cutoff 0.83",
       x = "flg22 Variants", y = "Percentage") +
  my_ggplot_theme +
   scale_y_continuous(expand = c(0, 0), limits = c(0, 105))+
   scale_x_discrete(expand = c(0, 0))+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Add similarity data as a line plot over the bars
final_plot <- stacked_plot +
  geom_line(data = similarity_data, aes(x = flg22_variants, y = sim, group = 1), color = "black", size = 0.8, inherit.aes = FALSE, alpha = 0.7) +
  geom_point(data = similarity_data, aes(x = flg22_variants, y = sim), color = "black", size = 1.2, inherit.aes = FALSE)

# Display the combined plot
print(final_plot)

# Optionally, save the plot
ggsave("../output/af3/combined_metrics_similarity_plot.pdf", final_plot, width = 10, height = 6)


```



###Scatterplot, ipTM and pTM
```{r}
# Load necessary libraries
library(ggplot2)
library(pROC)
library(readr)  # Use read_csv from readr

# Read the data from the CSV file
data <- read_csv("../input/af3/ipTM_ploting.csv")  # Ensure the correct path and file extension

# Ensure the experimental results are properly formatted
data$Experimental_Result <- as.factor(data$Experimental_Result)

# Calculate the ROC curve
roc_obj <- roc(response = data$Experimental_Result, predictor = data$Average_ipTM)

# Extract coordinates for the ROC curve
coords <- coords(roc_obj, "all", ret = c("threshold", "sensitivity", "specificity", "accuracy"))
coords_df <- as.data.frame(coords)  # Convert to data frame for ggplot

# Calculate AUC
auc_value <- auc(roc_obj)

# Calculate maximum accuracy index
max_acc_index <- which.max(coords_df$accuracy)

# Plot the ROC curve using ggplot2
roc_plot <- ggplot(coords_df, aes(x = 1 - specificity, y = sensitivity)) +
  geom_line(color = "#4477aa", size = 1.2) +
  geom_line(data = data.frame(x = c(0, 1), y = c(0, 1)), aes(x, y), linetype = "dashed", color = "navy") +
  geom_point(aes(x = 1 - specificity[max_acc_index], y = sensitivity[max_acc_index]), color = "black", size = 2) +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 1), breaks = c(0, 0.25, 0.5, 0.75, 1), labels = c("0", "0.25", "0.5", "0.75", "1")) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 1), breaks = c(0, 0.25, 0.5, 0.75, 1), labels = c("0", "0.25", "0.5", "0.75", "1")) +
  labs(title = sprintf("ROC Curve with AUC: %.2f", auc_value), 
       subtitle = sprintf("Optimal Threshold: %.2f", coords_df$threshold[max_acc_index]),
       x = "False Positive Rate", y = "True Positive Rate") +
 my_ggplot_theme

# Print the plot
print(roc_plot)

# Save the plot
ggsave("../output/af3/ROC.pdf", plot = roc_plot, width = 6, height = 6, dpi = 300)

```


```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(readr)  # For reading the CSV file

# Read the data from a CSV file
data <- read_csv("../input/af3/ipTM_ploting.csv")

# Assuming the data has columns 'Experimental_Result' and 'Average_ipTM'
data <- data %>%
  mutate(Experimental_Result = factor(Experimental_Result))

# Creating the raincloud plot
ggplot(data, aes(x = Experimental_Result, y = Average_ipTM, fill = Experimental_Result)) +
  geom_violin(trim = FALSE, alpha = 0.5, color = NA) +  # Density plot
  geom_boxplot(width = 0.03, outlier.shape = NA, alpha = 0.5) +  # Boxplot inside the violin
  geom_jitter(size = 1, alpha = 0.8, color = "black", width = 0.1) +  # Points with jitter
  scale_fill_manual(values = c("#ccbb44", "#4477aa")) +  # Custom colors for each experimental result
  labs(title = "Raincloud Plot of Average ipTM by Experimental Result",
       x = "Experimental Result",
       y = "Average ipTM") +
  #geom_hline(yintercept = 0.83, linetype = "solid", color = "darkgrey", size = 0.5) +
 my_ggplot_theme

# Optionally, you can save the plot to a file
ggsave("../output/af3/raincloud.pdf", width = 10, height = 6, dpi = 300)


```